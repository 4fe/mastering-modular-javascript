[[shaping-internals]]
== Shaping Internals

Thus far we've addressed modular design and API design concerns from a high level perspective, but avoided plunging into the deep end of implementation details. In contrast, this chapter is devoted to advice and concrete actions we can take to improve the quality of our component implementations. We'll discuss complexity, ways to remediate it, the perils of state, and how to better leverage data structures.

=== 4.1 Internal Complexity

Every piece of code we write is a source of internal complexity, with the potential to become a large pain point for our codebase as a whole. That said, most bits of code are relatively harmless when compared to the entire corpus of our codebase, and trying to proof our code against complexity is a sure way of increasing complexity for no observable benefit. The question is, then, how do we identify the small problems before they grow into a serious threat to the maintainability of our project?

Making a conscious effort to track pieces of code that we haven't changed or interacted with in a while, and identifying if they're simple enough to understand can help us determine whether refactoring may be in order. We could perhaps set a rule whereby team members should watch out for garden paths in the codebase and fix them as they are making changes in the same functional area as the affected code. When we track complexity methodically, often, and across the entire team that's responsible for a codebase, we can expect to see many small but cumulative gains in our battle against complexity.

==== 4.1.1 Containing Nested Complexity

In JavaScript, deep nesting is one of the clearest signs of complexity. Understanding the code at any given nesting level involves understanding how the flow arrives there, the state at every level in scope, how the flow might break out of the level, and which other flows might lead to the same level. Granted, we don't always need to keep all this derived information in our memory. The problem is that, when we do, we might have to spend quite a few minutes reading and understanding the code, deriving such information, and otherwise not fixing the bug or implementing the feature that we had set out to resolve in the first place.

Nesting is the underlying source of complexity in patterns such as "Callback Hell", or "Promise Hell", where callbacks are nested on top of one another. The complexity has little to do with spacing, although when taken to the extreme it does make code harder to read. Instead, the complexity exists at the seams, where we need to fully understand the context in order to go deep into the callback chain and make fixes or improvements. An insidious variant of callback hell is the one where we have logic in every nesting level. This variant is coincidentally the one we can observe most often in real applications: we rarely have callbacks as depicted in the bit of code below, partly because it's immediately obvious that something is wrong. We should probably either change the API so that we get everything we need at once, or we could leverage a small library that takes care of the flow while eliminating the deep nesting we'd otherwise have in our own code.

[source,javascript]
----
getProducts(products => {
  getProductPrices(products, prices => {
    getProductDetails({ products, prices }, details => {
      // â€¦
    })
  })
})
----

When we have synchronous logic intermixed with asynchronous callbacks, things get more challenging. The problem here is, almost always, a coupling of concerns. When a program has a series of nested callbacks that also include logic in between, it can be a sign that we're mixing flow control concerns with business concerns. In other words, our program would be in a better place if we kept the flow separate from the business logic. By splitting the code that purely determines the flow from the rest, we can better isolate our logic into its individual components. The flow, in turn, also becomes more clear because it's now spelled out in plain sight instead of interleaved with business concerns.

Suppose that each nesting level in a series of callbacks contains about 50 lines of code. Each function in the series needs to reference zero, one, or more variables in its parent scope. If it needs zero references to its immediate parent scope, we can safely move it up to the same scope as its parent. We can repeat this process until the function is in the highest possible level where it can, given the variables it has to reference. When functions reference at least one variable from the parent scope, we could opt to leave them unchanged or to pass those references as parameters so that we can keep on decoupling the functions.

As we move logic into their own functions and flatten the callback chain, we'll be left with the bare flow of operations being separate from the operations themselves. Libraries like `contra` can help manage the flow itself while user code worries about business logic.

==== 4.1.2 Feature Entanglement and Tight Coupling

As a module becomes larger, it becomes easier to mistakenly collapse distinct features together by interleaving their code in such a way that it becomes hard to reuse each feature independently, debug and maintain them, or otherwise extricate the features from one another.

As an example, if we have a feature for notifying subscribers and a feature to send notifications, we could strive to keep the features apart by clearly defining how notifications can be constructed and handed off to a different service which then sends those notifications. That way, subscriber notifications can be sent through the notification service, but given the clear separation we won't be prevent subscriber-specific notions from getting in the way of sending other kinds of notifications to our customers.

..




==== 4.1.3 Conventions: the Good the Bad and the Ugly

Conventions are useful because they allow for better self-direction amongst developers, without causing lagoons of inconsistency to spread across our codebase as fate would have it were we to allow a team of developers too much freedom without sound design direction and conventions that dictatehow different portions of an application should be shaped. A large number of conventions might hinder productivity, especially if some of our conventions appeared to work as if by magic.

..

=== 4.2 Refactoring Complex Code

..

==== 4.2.1 Using Variables

.. use intermediary variables to improve readability, shy away from ternaries, const->let->var, etc.

==== 4.2.2 Guard Clauses and Branch Flipping

..

> When we have long branches followed by an `else` and a shorter branch (generally the shorter branch would log an error, `throw`, return, or otherwise perform a failure handling), it's best to exit early by flipping the `if` condition, placing the short branch first, and returning. Here, I'm referring to the `if (response.status < 300) {` query. If we turn this into `response.status >= 300`, then when reading the code we immediately learn that it wouldn't continue for status codes beyond `299`. When done systematically, this makes the code easier to follow.

==== 4.2.3 An Interdependency Piramid

writing functions in the order that they're meant to be read, so that it's easy to read for humans to read than the other way around

==== 4.2.3 Extracting Functions

e.g let with no assignment to const, moving mappers to bottom, anything that gets in the way of *current* flow we defer for later.

==== 4.2.4 Flattening Nested Callbacks

.. tips/tricks to deal w async flows

==== 4.2.5 Factoring Similar Tasks

.. (such as when we do `createTaskFor(articles)` and `createTaskFor(weeklies)`), or maybe passing a few things but preserving internal task flow overall

==== 4.2.6 Disentangling Headphone Wires

.. a bit of a rehash of 4.2.2 where we visit how we can decouple unrelated functionality by creating focused functions under a shared scope.

==== 4.2.7 Slicing Large Functions

When all else fails, consider breaking what would otherwise inevitably be a large function into smaller functions.

.. how these can be organized by splitting the functionality by steps, aspects, or any other logical grouping we can come up with


=== 4.3 State as Entropy

..

==== 4.3.1 It's Complicated

section on how state is terrible and the more state there is the less predictable our code becomes.

==== 4.3.2 Eliminating Incidental State

.. where possible always recompute state from data rather than rely on state

==== 4.3.3 Containing State

.. when we must have state, keep it as constrained as possible

==== 4.3.4 Leveraging Immutability

..

=== 4.4 Data Structures are King

.. a section on how data structures make or break an application, and why data-driven is better than state or logic driven

==== 4.4.1 Isolating Data

.. Keeping data separate from methods that modify or access said data can help reduce complexity. When data is not cluttered with functionality, it becomes easier to read, understand, and serialize.

==== 4.4.2 Restricting Domain Logic

.. We should strive to keep code that knows about a particular data structure or set of structures contained in as few modules as possible. Should the data structures or the logic around them require changes, the ripple effects of those changes can be devastating if domain logic is spread across the codebase.

==== 4.4.3 Choosing Data Over Code

.. How the right data structures can make our code much easier to write and read. It might be worth mapping data into something that's amenable to the task at hand, so that the algorithm is simplified by making the data easier to consume.

==== 4.4.4 Reducing, Mapping, Filtering, and Sorting Data

..




---

most of this chapter should be javascript code programming best practices:
look up code and figure out things you did. compare to code other people wrote and identify problems, explain.

---
